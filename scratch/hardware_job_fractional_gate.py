import ffsim
from qiskit.circuit import QuantumCircuit, QuantumRegister
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit.transpiler.passes import RemoveIdentityEquivalent
from qiskit.transpiler import PassManager
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import SamplerV2 as Sampler
from qiskit_ibm_runtime.transpiler.passes import FoldRzzAngle
from ffsim.variational.util import interaction_pairs_spin_balanced
from lucj.hardware_sqd_task.hardware_job.layout import get_zigzag_physical_layout
import pickle

import numpy as np
from qiskit_addon_sqd.fermion import diagonalize_fermionic_hamiltonian, SCIResult
from qiskit_addon_sqd.counts import bit_array_to_arrays, bitstring_matrix_to_integers
from qiskit_addon_sqd.subsampling import postselect_by_hamming_right_and_left
from qiskit_addon_dice_solver import solve_sci_batch
import os

from molecules_catalog.util import load_molecular_data

def constrcut_lucj_circuit(norb, nelec, operator):
    qubits = QuantumRegister(2 * norb)
    circuit = QuantumCircuit(qubits)
    circuit.append(ffsim.qiskit.PrepareHartreeFockJW(norb, nelec), qubits)
    circuit.append(ffsim.qiskit.UCJOpSpinBalancedJW(operator), qubits)
    circuit.measure_all()
    return circuit


def run_on_hardware(
    circuit: QuantumCircuit,
    norb,
    shots,
    sample_folder: str,
    dynamic_decoupling=True,
):
    service = QiskitRuntimeService(name="wanhsuan-lucj")
    # backend = service.backend("ibm_fez", use_fractional_gates=True)
    backend = service.backend("ibm_pittsburgh", use_fractional_gates=True)

    initial_layout, _ = get_zigzag_physical_layout(norb, backend=backend)
    # initial_layout: [1, 4, 0] program qubit 0 is mapped to physical qubit 1
    print(initial_layout)
    # with PRE_INIT passes
    # We will use the circuit generated by this pass manager for hardware execution
    list_isa_circuit = []
    pass_manager = generate_preset_pass_manager(
        optimization_level=0,
        backend=backend,
        initial_layout=initial_layout,
        seed_transpiler=0,
    )
    ffsim_pass = ffsim.qiskit.PRE_INIT
    # ffsim_pass.append(RemoveIdentityEquivalent())
    # print(ffsim_pass)
    pass_manager.pre_init = ffsim_pass
    pass_manager.post_init = PassManager([RemoveIdentityEquivalent()])
    pass_manager.post_optimization = PassManager(
        [
            FoldRzzAngle(),
            RemoveIdentityEquivalent(target=backend.target),
        ]
    )
    isa_circuit = pass_manager.run(circuit)
    print(f"Circuit: Gate counts (w/ pre-init passes): {isa_circuit.count_ops()}")
    print(f"Circuit: gate depth: {isa_circuit.depth()}")
    n_runs = 5
    for _ in range(n_runs):
        list_isa_circuit.append(isa_circuit)

    # sampler = Sampler(mode=backend)

    # if dynamic_decoupling:
    #     print("Use dynamic decoupling")
    #     sampler.options.dynamical_decoupling.enable = True
    #     sampler.options.dynamical_decoupling.sequence_type = "XY4"

    # job = sampler.run(list_isa_circuit, shots=shots)

    job = service.job('d2mar94g59ks73c6ac4g') # ibm pit
    # job = service.job('d2nk4dm97thc73au3e50')
    # job = service.job('d2nh1ssg59ks73c7eva0')
    # job = service.job('d2ngvlfa6cjs73fcpom0')

    meas_circuit = []

    primitive_result = job.result()

    os.makedirs(sample_folder, exist_ok=True)
    list_sample_filenames = [f"{sample_folder}/sample_{i}.pickle " for i in range(n_runs)]

    for pub_result, sample_filename in zip(primitive_result, list_sample_filenames):
        meas_circuit.append(pub_result.data.meas)
        # with open(sample_filename, "wb") as f:
        #     pickle.dump(pub_result.data.meas, f)
        # print(f"save file to {sample_filename}")
            

    return meas_circuit

nelectron, norb = 10, 26
nelec = (nelectron, nelectron)

pairs_aa, pairs_ab = interaction_pairs_spin_balanced("heavy-hex", norb)

operator = ffsim.random.random_ucj_op_spin_balanced(
    norb,
    n_reps=1,
    interaction_pairs=(pairs_aa, pairs_ab),
    with_final_orbital_rotation=True,
)

circuit = constrcut_lucj_circuit(norb, nelec, operator)
list_samples = run_on_hardware(
    circuit,
    norb,
    1_000_000,
    sample_folder="scratch",
    dynamic_decoupling=True,
)

molecule_name = "n2"
basis = "cc-pvdz"
molecule_basename = f"{molecule_name}_{basis}_{nelectron}e{norb}o"
bond_distance = 1.2
mol_data = load_molecular_data(
        f"{molecule_basename}_d-{bond_distance:.5f}",
        molecules_catalog_dir="/home/WanHsuan.Lin/molecules-catalog",
    )

for i, samples in enumerate(list_samples):
    # if i == 0:
    #     continue
    # Convert BitArray into bitstring and probability arrays
    raw_bitstrings, raw_probs = bit_array_to_arrays(samples)

    # Run configuration recovery loop
    # If we don't have average orbital occupancy information, simply postselect
    # bitstrings with the correct numbers of spin-up and spin-down electrons
    bitstrings, probs = postselect_by_hamming_right_and_left(
        raw_bitstrings,
        raw_probs,
        hamming_right=nelec[0],
        hamming_left=nelec[1],
    )

    unique_valid_bitstr, _ = np.unique(
        bitstring_matrix_to_integers(bitstrings), return_counts=True
    )
    print(f"Job {i} - #Total valid bitstr: {bitstrings.shape}, #total unique bitstr: {len(unique_valid_bitstr)}\n")

    rng = np.random.default_rng(0)
    
    # def callback(results: list[SCIResult]):
    #     for i, result in enumerate(results):
    #         print(f"\tSubsample {i}")
    #         print(f"\t\tEnergy: {result.energy + mol_data.core_energy}")
    #         print(
    #             f"\t\tSubspace dimension: {np.prod(result.sci_state.amplitudes.shape)}"
    #         )
            
    # result = diagonalize_fermionic_hamiltonian(
    #         mol_data.hamiltonian.one_body_tensor,
    #         mol_data.hamiltonian.two_body_tensor,
    #         samples,
    #         samples_per_batch=4000,
    #         norb=norb,
    #         nelec=nelec,
    #         num_batches=10,
    #         max_iterations=1,
    #         sci_solver=solve_sci_batch,
    #         symmetrize_spin=True,
    #         seed=rng,
    #         callback=callback,
    #         max_dim=4000,
    #     )


