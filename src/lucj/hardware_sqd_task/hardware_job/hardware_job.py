import ffsim
from qiskit.circuit import QuantumCircuit, QuantumRegister
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
 
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import SamplerV2 as Sampler

from lucj.hardware_sqd_task.hardware_job.layout import get_zigzag_physical_layout
from qiskit.primitives import BitArray
# import mthree
import pickle

def constrcut_lucj_circuit(norb, nelec, operator):
    qubits = QuantumRegister(2 * norb)
    circuit = QuantumCircuit(qubits)
    circuit.append(ffsim.qiskit.PrepareHartreeFockJW(norb, nelec), qubits)
    circuit.append(ffsim.qiskit.UCJOpSpinBalancedJW(operator), qubits)
    circuit.measure_all()
    return circuit

def run_on_hardware(circuit: QuantumCircuit, norb, shots, sample_filename, dynamic_decoupling = False):
    service = QiskitRuntimeService(name="wanhsuan-lucj")
    # service = QiskitRuntimeService(name="wanhsuan-lucj-internal")
    # backend = service.least_busy(
    #     operational=True, simulator=False, min_num_qubits=127
    # )
    # backend = service.backend("alt_pittsburgh")
    backend = service.backend("ibm_pittsburgh")

    initial_layout, _ = get_zigzag_physical_layout(norb, backend=backend)
    # initial_layout: [1, 4, 0] program qubit 0 is mapped to physical qubit 1
    pass_manager = generate_preset_pass_manager(
        optimization_level=1, backend=backend, initial_layout=initial_layout
    )
    
    # without PRE_INIT passes
    # isa_circuit = pass_manager.run(circuit)
    # print(f"Gate counts (w/o pre-init passes): {isa_circuit.count_ops()}")
    
    # with PRE_INIT passes
    # We will use the circuit generated by this pass manager for hardware execution
    pass_manager.pre_init = ffsim.qiskit.PRE_INIT
    isa_circuit = pass_manager.run(circuit)
    print(f"Gate counts (w/ pre-init passes): {isa_circuit.count_ops()}")
    # assert 0
    sampler = Sampler(mode=backend)

    if dynamic_decoupling:
        print("Use dynamic decoupling")
        sampler.options.dynamical_decoupling.enable = True
        sampler.options.dynamical_decoupling.sequence_type = 'XY4'


    job = sampler.run([isa_circuit], shots=shots)

    primitive_result = job.result()
    pub_result = primitive_result[0]
    with open(sample_filename, "wb") as f:
            pickle.dump(pub_result.data.meas, f)
    return pub_result.data.meas

    # Specify a mitigator object targeting a given backend
    # mit = mthree.M3Mitigation(backend)
    # mit.cals_from_system(initial_layout)
    # # Apply mitigation to a given dict of raw counts over the specified qubits
    # raw_counts = pub_result.data.meas.get_counts()
    # m3_quasi = mit.apply_correction(raw_counts, initial_layout)
    # prob = m3_quasi.nearest_probability_distribution()
    # for key in prob:
    #     prob[key] = int(prob[key] * shots)

    # bit_array = BitArray.from_counts(prob, num_bits=2 * norb)

    # with open(mitigate_sample_filename, "wb") as f:
    #     pickle.dump(bit_array, f)
    
    # return bit_array
