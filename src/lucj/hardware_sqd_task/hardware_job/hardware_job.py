import ffsim
from qiskit.circuit import QuantumCircuit, QuantumRegister
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
 
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import SamplerV2 as Sampler

from lucj.hardware_sqd_task.hardware_job.layout import get_zigzag_physical_layout

def constrcut_lucj_circuit(norb, nelec, operator):
    qubits = QuantumRegister(2 * norb)
    circuit = QuantumCircuit(qubits)
    circuit.append(ffsim.qiskit.PrepareHartreeFockJW(norb, nelec), qubits)
    circuit.append(ffsim.qiskit.UCJOpSpinBalancedJW(operator), qubits)
    circuit.measure_all()
    return circuit

def run_on_hardware(circuit: QuantumCircuit, norb, shots):
    service = QiskitRuntimeService(name="wanhsuan-lucj")
    # service = QiskitRuntimeService(name="wanhsuan-lucj-internal")
    # backend = service.least_busy(
    #     operational=True, simulator=False, min_num_qubits=127
    # )
    # backend = service.backend("alt_pittsburgh")
    backend = service.backend("ibm_pittsburgh")

    initial_layout, _ = get_zigzag_physical_layout(norb, backend=backend)
 
    pass_manager = generate_preset_pass_manager(
        optimization_level=3, backend=backend, initial_layout=initial_layout
    )
    
    # without PRE_INIT passes
    isa_circuit = pass_manager.run(circuit)
    print(f"Gate counts (w/o pre-init passes): {isa_circuit.count_ops()}")
    
    # with PRE_INIT passes
    # We will use the circuit generated by this pass manager for hardware execution
    pass_manager.pre_init = ffsim.qiskit.PRE_INIT
    isa_circuit = pass_manager.run(circuit)
    print(f"Gate counts (w/ pre-init passes): {isa_circuit.count_ops()}")

    sampler = Sampler(mode=backend)
    job = sampler.run([isa_circuit], shots=shots)

    primitive_result = job.result()
    pub_result = primitive_result[0]
    return pub_result.data.meas
