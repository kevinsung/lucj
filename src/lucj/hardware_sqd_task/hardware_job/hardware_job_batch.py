import ffsim
from qiskit.circuit import QuantumCircuit, QuantumRegister
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import SamplerV2 as Sampler

from lucj.hardware_sqd_task.hardware_job.layout import get_zigzag_physical_layout
from qiskit.primitives import BitArray
import pickle


def constrcut_lucj_circuit(norb, nelec, operator):
    qubits = QuantumRegister(2 * norb)
    circuit = QuantumCircuit(qubits)
    circuit.append(ffsim.qiskit.PrepareHartreeFockJW(norb, nelec), qubits)
    circuit.append(ffsim.qiskit.UCJOpSpinBalancedJW(operator), qubits)
    circuit.measure_all()
    return circuit


def run_on_hardware(
    list_circuit: list[QuantumCircuit],
    norb,
    shots,
    list_sample_filenames,
    dynamic_decoupling=True,
):
    service = QiskitRuntimeService(name="wanhsuan-lucj")
    # service = QiskitRuntimeService(name="wanhsuan-lucj-internal")
    # backend = service.least_busy(
    #     operational=True, simulator=False, min_num_qubits=127
    # )
    # backend = service.backend("alt_pittsburgh")
    backend = service.backend("ibm_pittsburgh")

    initial_layout, _ = get_zigzag_physical_layout(norb, backend=backend)
    # initial_layout: [1, 4, 0] program qubit 0 is mapped to physical qubit 1
    pass_manager = generate_preset_pass_manager(
        optimization_level=3, backend=backend, initial_layout=initial_layout
    )

    # with PRE_INIT passes
    # We will use the circuit generated by this pass manager for hardware execution
    list_isa_circuit = []
    pass_manager.pre_init = ffsim.qiskit.PRE_INIT
    for circuit in list_circuit:
        isa_circuit = pass_manager.run(circuit)
        print(f"Circuit: Gate counts (w/ pre-init passes): {isa_circuit.count_ops()}")
        list_isa_circuit.append(isa_circuit)
    
    assert(len(list_isa_circuit) == 3)
    
    sampler = Sampler(mode=backend)

    if dynamic_decoupling:
        print("Use dynamic decoupling")
        sampler.options.dynamical_decoupling.enable = True
        sampler.options.dynamical_decoupling.sequence_type = "XY4"


    job = sampler.run(list_isa_circuit, shots=shots)

    meas_circuit = []

    primitive_result = job.result()
    
    for pub_result, sample_filename in zip(primitive_result, list_sample_filenames):
        meas_circuit.append(pub_result.data.meas)
        with open(sample_filename, "wb") as f:
            pickle.dump(pub_result.data.meas, f)
        print(f"save file to {sample_filename}")
    return meas_circuit
